// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../src/UPS.sol";
import {IERC20} from "../src/interfaces/IERC20.sol";

interface IPancakePair {
    function swap(
        uint amount0Out,
        uint amount1Out,
        address to,
        bytes calldata data
    ) external;
    function sync() external;
    function getReserves() external view returns (uint112, uint112, uint32);
}

interface IVToken {
    function mint(uint mintAmount) external returns (uint);
    function borrow(uint borrowAmount) external returns (uint);
    function repayBorrow(uint repayAmount) external returns (uint);
    function redeem(uint redeemTokens) external returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function underlying() external view returns (address);
}

interface IComptroller {
    function enterMarkets(
        address[] calldata vTokens
    ) external returns (uint[] memory);
}

interface IPancakeRouter {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

contract UtopiaSphereExploitTest is Test {
    address constant EXPLOITER = 0x6e12ce089a8BedeA49532010229f0913475d8d9c;
    address constant UPS_ADDR = 0xe2bb1B04c978A8C8CC1E0bccA5AD30e274b69Bfa;
    address constant PAIR = 0x5dB4604c8952A8C3474e8aC33E0d31814d75F786; // UPS/USDT pair
    address constant USDT = 0x55d398326f99059fF775485246999027B3197955;
    address constant USDC = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d;
    address constant VUSDC = 0xecA88125a5ADbe82614ffC12D0DB554E2e2867C8;
    address constant VUSDT = 0xfD5840Cd36d94D7229439859C0112a4185BC0255;
    address constant COMPTROLLER = 0xfD36E2c2a6789Db23113685031d7F16329158384;
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E; // PancakeRouter

    function setUp() public {
        // Try with a more recent block or use latest
        vm.createSelectFork("bsc"); // Use latest block instead of specific historical block
    }

    function testExploit() public {
        // First, let's check what addresses are whitelisted
        console.log("Test contract address:", address(this));
        console.log("Pair address:", PAIR);
        console.log("UPS contract address:", UPS_ADDR);
        
        // Get the actual UPS contract instance to check whitelist
        UPS upsContract = UPS(UPS_ADDR);
        console.log("Is test contract whitelisted:", upsContract.whiteMap(address(this)));
        console.log("Is pair whitelisted:", upsContract.whiteMap(PAIR));
        
        // Simplified exploit test focusing on the core mechanism
        // Simulate flashloan by dealing USDT to this contract
        uint flashLoanedUSDT = 1_000_000 * 1e18; // Start with smaller amount for testing
        deal(USDT, address(this), flashLoanedUSDT);

        console.log("Initial USDT balance:", IERC20(USDT).balanceOf(address(this)));

        // Try to get the current price first
        uint256 currentPrice = upsContract.getPrice();
        console.log("Current UPS price:", currentPrice);
        
        // Check reserves
        (uint256 reserve0, uint256 reserve1,) = IPancakePair(PAIR).getReserves();
        console.log("Pair reserves - reserve0:", reserve0);
        console.log("Pair reserves - reserve1:", reserve1);
        
        // We'll start with a simple direct transfer test
        console.log("Attempting to get some UPS first through deal...");
        deal(UPS_ADDR, address(this), 1000 * 1e18);
        uint256 testUpsBalance = IERC20(UPS_ADDR).balanceOf(address(this));
        console.log("Dealt UPS balance:", testUpsBalance);
    }
}
